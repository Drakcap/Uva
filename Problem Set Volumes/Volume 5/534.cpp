#include <iostream>#include <vector>#include <set>#include <list>#include <cstdlib>#include <cstdio>#include <cstring>#include <string>#include <map>#include <queue>#include <iomanip>#include <algorithm>#include <cmath>using namespace std;#define MAXV 200#define INF 2000000000struct Stone {    int x, y;} stones[200];double dist(int s1, int s2){    int x1 = stones[s1].x, x2 = stones[s2].x, y1 = stones[s1].y, y2 = stones[s2].y;    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}struct amGraph{ // Adjency Matrix Graph  int n;  double edge[MAXV][MAXV] ;   void init(int size, int val=INF) { n= size; for (int i = 0; i < n; i++)     for (int j = 0; j < n; j++) edge[i][j] = val;}  void addEdge(int src, int dst, double c) { edge[src][dst] = c; }};void floyd(amGraph & g) {  for(int i=0; i<g.n; i++) g.edge[i][i] = 0;  for(int k=0; k<g.n; k++)    for(int i=0; i<g.n; i++)      if (g.edge[i][k] != INF)        for(int j=0; j<g.n; j++)          g.edge[i][j] = (float)min(g.edge[i][j], max(g.edge[i][k],g.edge[k][j]));}int N;amGraph g;int main(){    int cenario = 1;    cout.setf(ios::fixed);        while (cin >> N && N != 0) {        g.init(N);                for (int i = 0; i < N; i++) {            cin >> stones[i].x >> stones[i].y;        }                double d = 0.;        for (int i = 0; i < N; i++) {            for (int j = i+1; j < N; j++) {                d = dist(i, j);                g.addEdge(i, j, d);                g.addEdge(j, i, d);            }        }        floyd(g);        cout << "Scenario #" << cenario++ << endl;        cout << "Frog Distance = " << setprecision(3) << g.edge[0][1] << endl << endl;    }    return 0;}